var $1IdlX$react = require("react");

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useDraggableCollectionState", () => $481a240e3d51b276$export$29efd034f1d79f81);
$parcel$export(module.exports, "useDroppableCollectionState", () => $6ce4cbfbe5e354f1$export$926850f6ecef79d0);

function $481a240e3d51b276$export$29efd034f1d79f81(props) {
    let { getItems: getItems , collection: collection , selectionManager: selectionManager , onDragStart: onDragStart , onDragMove: onDragMove , onDragEnd: onDragEnd , preview: preview , getAllowedDropOperations: getAllowedDropOperations  } = props;
    let [, setDragging] = $1IdlX$react.useState(false);
    let draggingKeys = $1IdlX$react.useRef(new Set());
    let draggedKey = $1IdlX$react.useRef(null);
    let getKeys = (key1)=>{
        // The clicked item is always added to the drag. If it is selected, then all of the
        // other selected items are also dragged. If it is not selected, the only the clicked
        // item is dragged. This matches native macOS behavior.
        let keys = new Set(selectionManager.isSelected(key1) ? new Set([
            ...selectionManager.selectedKeys
        ].filter((key)=>!!collection.getItem(key)
        )) : []);
        keys.add(key1);
        return keys;
    };
    return {
        collection: collection,
        selectionManager: selectionManager,
        get draggedKey () {
            return draggedKey.current;
        },
        get draggingKeys () {
            return draggingKeys.current;
        },
        isDragging (key) {
            return draggingKeys.current.has(key);
        },
        getKeysForDrag: getKeys,
        getItems (key) {
            return getItems(getKeys(key));
        },
        preview: preview,
        getAllowedDropOperations: getAllowedDropOperations,
        startDrag (key, event) {
            setDragging(true);
            let keys = getKeys(key);
            draggingKeys.current = keys;
            draggedKey.current = key;
            if (typeof onDragStart === 'function') onDragStart({
                ...event,
                keys: keys
            });
        },
        moveDrag (event) {
            if (typeof onDragMove === 'function') onDragMove({
                ...event,
                keys: draggingKeys.current
            });
        },
        endDrag (event) {
            if (typeof onDragEnd === 'function') onDragEnd({
                ...event,
                keys: draggingKeys.current
            });
            setDragging(false);
            draggingKeys.current = new Set();
            draggedKey.current = null;
        }
    };
}



function $6ce4cbfbe5e354f1$export$926850f6ecef79d0(props) {
    let [target1, setTarget] = $1IdlX$react.useState(null);
    let getOppositeTarget = (target)=>{
        if (target.dropPosition === 'before') {
            let key = props.collection.getKeyBefore(target.key);
            return key != null ? {
                type: 'item',
                key: key,
                dropPosition: 'after'
            } : null;
        } else if (target.dropPosition === 'after') {
            let key = props.collection.getKeyAfter(target.key);
            return key != null ? {
                type: 'item',
                key: key,
                dropPosition: 'before'
            } : null;
        }
    };
    return {
        collection: props.collection,
        selectionManager: props.selectionManager,
        target: target1,
        setTarget (newTarget) {
            if (this.isDropTarget(newTarget)) return;
            if (target1 && typeof props.onDropExit === 'function') props.onDropExit({
                type: 'dropexit',
                x: 0,
                y: 0,
                target: target1
            });
            if (newTarget && typeof props.onDropEnter === 'function') props.onDropEnter({
                type: 'dropenter',
                x: 0,
                y: 0,
                target: newTarget
            });
            setTarget(newTarget);
        },
        isDropTarget (dropTarget) {
            if ($6ce4cbfbe5e354f1$var$isEqualDropTarget(dropTarget, target1)) return true;
            // Check if the targets point at the same point between two items, one referring before, and the other after.
            if ((dropTarget === null || dropTarget === void 0 ? void 0 : dropTarget.type) === 'item' && (target1 === null || target1 === void 0 ? void 0 : target1.type) === 'item' && dropTarget.key !== target1.key && dropTarget.dropPosition !== target1.dropPosition && dropTarget.dropPosition !== 'on' && target1.dropPosition !== 'on') return $6ce4cbfbe5e354f1$var$isEqualDropTarget(getOppositeTarget(dropTarget), target1) || $6ce4cbfbe5e354f1$var$isEqualDropTarget(dropTarget, getOppositeTarget(target1));
            return false;
        },
        getDropOperation (target, types, allowedOperations) {
            return typeof props.getDropOperation === 'function' ? props.getDropOperation(target, types, allowedOperations) : allowedOperations[0];
        }
    };
}
function $6ce4cbfbe5e354f1$var$isEqualDropTarget(a, b) {
    if (!a) return !b;
    switch(a.type){
        case 'root':
            return (b === null || b === void 0 ? void 0 : b.type) === 'root';
        case 'item':
            return (b === null || b === void 0 ? void 0 : b.type) === 'item' && (b === null || b === void 0 ? void 0 : b.key) === a.key && (b === null || b === void 0 ? void 0 : b.dropPosition) === a.dropPosition;
    }
}




//# sourceMappingURL=main.js.map
